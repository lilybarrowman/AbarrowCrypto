package me.abarrow.cipher.blowfish;

import java.util.Arrays;

import me.abarrow.cipher.BlockCipher;
import me.abarrow.core.CryptoException;
import me.abarrow.core.CryptoUtils;

public class TwoFish extends BlockCipher {

  public static final int[][] Q_BOX_INDECIES = new int[][] { new int[] { 0, 0, 1, 1 }, new int[] { 0, 1, 1, 0 },
      new int[] { 1, 0, 0, 0 }, new int[] { 1, 1, 0, 1 } };

  public static final int[][] Q_BOXES = new int[][] {
      new int[] { 0xA9, 0x67, 0xB3, 0xE8, 0x04, 0xFD, 0xA3, 0x76, 0x9A, 0x92, 0x80, 0x78, 0xE4, 0xDD, 0xD1, 0x38, 0x0D,
          0xC6, 0x35, 0x98, 0x18, 0xF7, 0xEC, 0x6C, 0x43, 0x75, 0x37, 0x26, 0xFA, 0x13, 0x94, 0x48, 0xF2, 0xD0, 0x8B,
          0x30, 0x84, 0x54, 0xDF, 0x23, 0x19, 0x5B, 0x3D, 0x59, 0xF3, 0xAE, 0xA2, 0x82, 0x63, 0x01, 0x83, 0x2E, 0xD9,
          0x51, 0x9B, 0x7C, 0xA6, 0xEB, 0xA5, 0xBE, 0x16, 0x0C, 0xE3, 0x61, 0xC0, 0x8C, 0x3A, 0xF5, 0x73, 0x2C, 0x25,
          0x0B, 0xBB, 0x4E, 0x89, 0x6B, 0x53, 0x6A, 0xB4, 0xF1, 0xE1, 0xE6, 0xBD, 0x45, 0xE2, 0xF4, 0xB6, 0x66, 0xCC,
          0x95, 0x03, 0x56, 0xD4, 0x1C, 0x1E, 0xD7, 0xFB, 0xC3, 0x8E, 0xB5, 0xE9, 0xCF, 0xBF, 0xBA, 0xEA, 0x77, 0x39,
          0xAF, 0x33, 0xC9, 0x62, 0x71, 0x81, 0x79, 0x09, 0xAD, 0x24, 0xCD, 0xF9, 0xD8, 0xE5, 0xC5, 0xB9, 0x4D, 0x44,
          0x08, 0x86, 0xE7, 0xA1, 0x1D, 0xAA, 0xED, 0x06, 0x70, 0xB2, 0xD2, 0x41, 0x7B, 0xA0, 0x11, 0x31, 0xC2, 0x27,
          0x90, 0x20, 0xF6, 0x60, 0xFF, 0x96, 0x5C, 0xB1, 0xAB, 0x9E, 0x9C, 0x52, 0x1B, 0x5F, 0x93, 0x0A, 0xEF, 0x91,
          0x85, 0x49, 0xEE, 0x2D, 0x4F, 0x8F, 0x3B, 0x47, 0x87, 0x6D, 0x46, 0xD6, 0x3E, 0x69, 0x64, 0x2A, 0xCE, 0xCB,
          0x2F, 0xFC, 0x97, 0x05, 0x7A, 0xAC, 0x7F, 0xD5, 0x1A, 0x4B, 0x0E, 0xA7, 0x5A, 0x28, 0x14, 0x3F, 0x29, 0x88,
          0x3C, 0x4C, 0x02, 0xB8, 0xDA, 0xB0, 0x17, 0x55, 0x1F, 0x8A, 0x7D, 0x57, 0xC7, 0x8D, 0x74, 0xB7, 0xC4, 0x9F,
          0x72, 0x7E, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34, 0x6E, 0x50, 0xDE, 0x68, 0x65, 0xBC, 0xDB, 0xF8, 0xC8,
          0xA8, 0x2B, 0x40, 0xDC, 0xFE, 0x32, 0xA4, 0xCA, 0x10, 0x21, 0xF0, 0xD3, 0x5D, 0x0F, 0x00, 0x6F, 0x9D, 0x36,
          0x42, 0x4A, 0x5E, 0xC1, 0xE0 },
      new int[] { 0x75, 0xF3, 0xC6, 0xF4, 0xDB, 0x7B, 0xFB, 0xC8, 0x4A, 0xD3, 0xE6, 0x6B, 0x45, 0x7D, 0xE8, 0x4B, 0xD6,
          0x32, 0xD8, 0xFD, 0x37, 0x71, 0xF1, 0xE1, 0x30, 0x0F, 0xF8, 0x1B, 0x87, 0xFA, 0x06, 0x3F, 0x5E, 0xBA, 0xAE,
          0x5B, 0x8A, 0x00, 0xBC, 0x9D, 0x6D, 0xC1, 0xB1, 0x0E, 0x80, 0x5D, 0xD2, 0xD5, 0xA0, 0x84, 0x07, 0x14, 0xB5,
          0x90, 0x2C, 0xA3, 0xB2, 0x73, 0x4C, 0x54, 0x92, 0x74, 0x36, 0x51, 0x38, 0xB0, 0xBD, 0x5A, 0xFC, 0x60, 0x62,
          0x96, 0x6C, 0x42, 0xF7, 0x10, 0x7C, 0x28, 0x27, 0x8C, 0x13, 0x95, 0x9C, 0xC7, 0x24, 0x46, 0x3B, 0x70, 0xCA,
          0xE3, 0x85, 0xCB, 0x11, 0xD0, 0x93, 0xB8, 0xA6, 0x83, 0x20, 0xFF, 0x9F, 0x77, 0xC3, 0xCC, 0x03, 0x6F, 0x08,
          0xBF, 0x40, 0xE7, 0x2B, 0xE2, 0x79, 0x0C, 0xAA, 0x82, 0x41, 0x3A, 0xEA, 0xB9, 0xE4, 0x9A, 0xA4, 0x97, 0x7E,
          0xDA, 0x7A, 0x17, 0x66, 0x94, 0xA1, 0x1D, 0x3D, 0xF0, 0xDE, 0xB3, 0x0B, 0x72, 0xA7, 0x1C, 0xEF, 0xD1, 0x53,
          0x3E, 0x8F, 0x33, 0x26, 0x5F, 0xEC, 0x76, 0x2A, 0x49, 0x81, 0x88, 0xEE, 0x21, 0xC4, 0x1A, 0xEB, 0xD9, 0xC5,
          0x39, 0x99, 0xCD, 0xAD, 0x31, 0x8B, 0x01, 0x18, 0x23, 0xDD, 0x1F, 0x4E, 0x2D, 0xF9, 0x48, 0x4F, 0xF2, 0x65,
          0x8E, 0x78, 0x5C, 0x58, 0x19, 0x8D, 0xE5, 0x98, 0x57, 0x67, 0x7F, 0x05, 0x64, 0xAF, 0x63, 0xB6, 0xFE, 0xF5,
          0xB7, 0x3C, 0xA5, 0xCE, 0xE9, 0x68, 0x44, 0xE0, 0x4D, 0x43, 0x69, 0x29, 0x2E, 0xAC, 0x15, 0x59, 0xA8, 0x0A,
          0x9E, 0x6E, 0x47, 0xDF, 0x34, 0x35, 0x6A, 0xCF, 0xDC, 0x22, 0xC9, 0xC0, 0x9B, 0x89, 0xD4, 0xED, 0xAB, 0x12,
          0xA2, 0x0D, 0x52, 0xBB, 0x02, 0x2F, 0xA9, 0xD7, 0x61, 0x1E, 0xB4, 0x50, 0x04, 0xF6, 0xC2, 0x16, 0x25, 0x86,
          0x56, 0x55, 0x09, 0xBE, 0x91 } };

  private static final int BLOCK_BYTES = 16;

  private static final int ROUNDS = 16;

  private int[] roundKeys;

  private int[] S;

  public TwoFish() {
  }
  
  public TwoFish(byte[] key) {
    setKey(key);
  }
  
  
  public static int[] createSBoxes(byte[] key) {
    
    int k = key.length / 8;
    
    int[] sBoxes = new int[k];

    for (int i = 0; i < k; i++) {
      int a = key[i * 8] & 0xff;
      int b = key[i * 8 + 1] & 0xff;
      int c = key[i * 8 + 2] & 0xff;
      int d = key[i * 8 + 3] & 0xff;
      int e = key[i * 8 + 4] & 0xff;
      int f = key[i * 8 + 5] & 0xff;
      int g = key[i * 8 + 6] & 0xff;
      int h = key[i * 8 + 7] & 0xff;

      int s0 = rsMultiplyBytes(a, 0x1) ^ rsMultiplyBytes(b, 0xa4) ^ rsMultiplyBytes(c, 0x55) ^ rsMultiplyBytes(d, 0x87)
          ^ rsMultiplyBytes(e, 0x5a) ^ rsMultiplyBytes(f, 0x58) ^ rsMultiplyBytes(g, 0xdb) ^ rsMultiplyBytes(h, 0x9e);
      int s1 = rsMultiplyBytes(a, 0xa4) ^ rsMultiplyBytes(b, 0x56) ^ rsMultiplyBytes(c, 0x82) ^ rsMultiplyBytes(d, 0xf3)
          ^ rsMultiplyBytes(e, 0x1e) ^ rsMultiplyBytes(f, 0xc6) ^ rsMultiplyBytes(g, 0x68) ^ rsMultiplyBytes(h, 0xe5);
      int s2 = rsMultiplyBytes(a, 0x2) ^ rsMultiplyBytes(b, 0xa1) ^ rsMultiplyBytes(c, 0xfc) ^ rsMultiplyBytes(d, 0xc1)
          ^ rsMultiplyBytes(e, 0x47) ^ rsMultiplyBytes(f, 0xae) ^ rsMultiplyBytes(g, 0x3d) ^ rsMultiplyBytes(h, 0x19);
      int s3 = rsMultiplyBytes(a, 0xa4) ^ rsMultiplyBytes(b, 0x55) ^ rsMultiplyBytes(c, 0x87) ^ rsMultiplyBytes(d, 0x5a)
          ^ rsMultiplyBytes(e, 0x58) ^ rsMultiplyBytes(f, 0xdb) ^ rsMultiplyBytes(g, 0x9e) ^ rsMultiplyBytes(h, 0x3);

      sBoxes[k - i - 1] = (s3 << 24) + (s2 << 16) + (s1 << 8) + s0;
    }
    
    return sBoxes;
    
  }
  
  public static int[] expandRoundKeys(byte[] key) {
    
    int keyLength = key.length;
    
    int[] keyWords = CryptoUtils.intArrayFromBytes(key, 0, keyLength, true);
    
    int k = keyLength / 8;
        
    int[] evenKeyWords = new int[k];
    int[] oddKeyWords = new int[k];

    for (int n = 0; n < k; n++) {
      evenKeyWords[n] = keyWords[2 * n];
      oddKeyWords[n] = keyWords[2 * n + 1];
    }
    
    int[] rKeys = new int[40];
    
    int p = 0x1010101;
    for (int i = 0; i < 20; i++) {
      int A = h(2 * i * p, evenKeyWords);
      int B = CryptoUtils.rotateIntLeft(h((2 * i + 1) * p, oddKeyWords), 8);
      rKeys[2 * i] = A + B;
      rKeys[2 * i + 1] = CryptoUtils.rotateIntLeft(A + 2 * B, 9);
    }
    
    //security paranoia
    Arrays.fill(keyWords, CryptoUtils.ZERO_BYTE);
    Arrays.fill(evenKeyWords, CryptoUtils.ZERO_BYTE);
    Arrays.fill(oddKeyWords, CryptoUtils.ZERO_BYTE);

    
    return rKeys;
  }

  private static int h(int x, int[] list) {

    for (int n = list.length - 1; n >= 0; n--) {
      int x0 = Q_BOXES[Q_BOX_INDECIES[0][n]][x & 0xff];
      int x1 = Q_BOXES[Q_BOX_INDECIES[1][n]][(x >>> 8) & 0xff];
      int x2 = Q_BOXES[Q_BOX_INDECIES[2][n]][(x >>> 16) & 0xff];
      int x3 = Q_BOXES[Q_BOX_INDECIES[3][n]][(x >>> 24) & 0xff];

      x = ((x3 << 24) + (x2 << 16) + (x1 << 8) + x0) ^ list[n];
    }

    int y0 = Q_BOXES[1][x & 0xff];
    int y1 = Q_BOXES[0][(x >>> 8) & 0xff];
    int y2 = Q_BOXES[1][(x >>> 16) & 0xff];
    int y3 = Q_BOXES[0][(x >>> 24) & 0xff];

    return mds(y0, y1, y2, y3);
  }

  @Override
  public int getBlockBytes() {
    return TwoFish.BLOCK_BYTES;
  }

  private int g(int x) {
    return h(x, S);
  }

  private static int mds(int y0, int y1, int y2, int y3) {
    int z0 = mdsMultiplyBytes(y0, 0x1) ^ mdsMultiplyBytes(y1, 0xef) ^ mdsMultiplyBytes(y2, 0x5b) ^ mdsMultiplyBytes(y3, 0x5b);
    int z1 = mdsMultiplyBytes(y0, 0x5b) ^ mdsMultiplyBytes(y1, 0xef) ^ mdsMultiplyBytes(y2, 0xef) ^ mdsMultiplyBytes(y3, 0x1);
    int z2 = mdsMultiplyBytes(y0, 0xef) ^ mdsMultiplyBytes(y1, 0x5b) ^ mdsMultiplyBytes(y2, 0x1) ^ mdsMultiplyBytes(y3, 0xef);
    int z3 = mdsMultiplyBytes(y0, 0xef) ^ mdsMultiplyBytes(y1, 0x1) ^ mdsMultiplyBytes(y2, 0xef) ^ mdsMultiplyBytes(y3, 0x5b);

    return (z3 << 24) + (z2 << 16) + (z1 << 8) + z0;
  }

  public static int rsMultiplyBytes(int a, int b) {
    // given irreducible polynomial x^8+x^6+x^3+x^2+1
    return CryptoUtils.multiplyFiniteFieldBytes(a, b, 0x14d);
  }
  
  public static int mdsMultiplyBytes(int a, int b) {
    // given irreducible polynomial x^8+x^6+x^5+x^3+1
    return CryptoUtils.multiplyFiniteFieldBytes(a, b, 0x169);
  }

  private void F(int[] block, int r) {
    int a = block[0];
    int b = block[1];

    int t0 = g(a);
    int t1 = g(CryptoUtils.rotateIntLeft(b, 8));

    int ap = (t0 + t1) + roundKeys[2 * r + 8];
    int bp = (t0 + 2 * t1) + roundKeys[2 * r + 9];

    block[0] = CryptoUtils.rotateIntRight((ap ^ block[2]), 1);
    block[1] = bp ^ CryptoUtils.rotateIntLeft(block[3], 1);
    block[2] = a;
    block[3] = b;
  }
  
  private void inverseF(int[] block, int r) {
    int a = block[2];
    int b = block[3];

    int t0 = g(a);
    int t1 = g(CryptoUtils.rotateIntLeft(b, 8));
    
    int ap = (t0 + t1) + roundKeys[2 * r + 8];
    int bp = (t0 + 2 * t1) + roundKeys[2 * r + 9];

    block[2] = CryptoUtils.rotateIntLeft(block[0] , 1) ^ ap;
    block[3] = CryptoUtils.rotateIntRight(bp ^ block[1], 1);
    block[0] = a;
    block[1] = b;
  }

  @Override
  public byte[] encryptBlock(byte[] input, int srcPos, byte[] output, int destPos) throws CryptoException {
    if (!hasKey()) {
      throw new CryptoException(CryptoException.NO_KEY);
    }
    int[] block = new int[] { CryptoUtils.intFromBytes(input, srcPos, true) ^ roundKeys[0],
        CryptoUtils.intFromBytes(input, srcPos + 4, true) ^ roundKeys[1],
        CryptoUtils.intFromBytes(input, srcPos + 8, true) ^ roundKeys[2],
        CryptoUtils.intFromBytes(input, srcPos + 12, true) ^ roundKeys[3] };

    // 16 rounds
    for (int r = 0; r < TwoFish.ROUNDS; r++) {
      F(block, r);
    }

    CryptoUtils.intToBytes(block[2] ^ roundKeys[4], output, destPos, true);
    CryptoUtils.intToBytes(block[3] ^ roundKeys[5], output, destPos + 4, true);
    CryptoUtils.intToBytes(block[0] ^ roundKeys[6], output, destPos + 8, true);
    CryptoUtils.intToBytes(block[1] ^ roundKeys[7], output, destPos + 12, true);
    return output;
  }

  @Override
  public byte[] decryptBlock(byte[] input, int srcPos, byte[] output, int destPos) throws CryptoException {
    if (!hasKey()) {
      throw new CryptoException(CryptoException.NO_KEY);
    }
    int[] block = new int[] { CryptoUtils.intFromBytes(input, srcPos + 8, true) ^ roundKeys[6],
        CryptoUtils.intFromBytes(input, srcPos + 12, true) ^ roundKeys[7],
        CryptoUtils.intFromBytes(input, srcPos, true) ^ roundKeys[4],
        CryptoUtils.intFromBytes(input, srcPos + 4, true) ^ roundKeys[5] };

    // 16 rounds
    for (int r = TwoFish.ROUNDS - 1; r >= 0; r--) {
      inverseF(block, r);
    }

    CryptoUtils.intToBytes(block[0] ^ roundKeys[0], output, destPos, true);
    CryptoUtils.intToBytes(block[1] ^ roundKeys[1], output, destPos + 4, true);
    CryptoUtils.intToBytes(block[2] ^ roundKeys[2], output, destPos + 8, true);
    CryptoUtils.intToBytes(block[3] ^ roundKeys[3], output, destPos + 12, true);
    return output;
  }


  @Override
  public void removeKey() {
    if (!hasKey()) {
      return;
    }
    CryptoUtils.fillWithZeroes(S);
    CryptoUtils.fillWithZeroes(roundKeys);
    S = null;
    roundKeys = null;
  }


  @Override
  public void setKey(byte[] key) {
    removeKey();
    if (key.length != 32) {
      Arrays.copyOf(key, 32);
    }
    S = createSBoxes(key);
    roundKeys = expandRoundKeys(key);
  }

  @Override
  public boolean hasKey() {
    return roundKeys != null;
  }

}
